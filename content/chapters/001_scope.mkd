title: Scopes, Targeting the Data Model
category: chapter
slug: scopes
chapter: 001

---

Angular **scopes** are objects that gives us access to the model. Remember the
model holds the data and state of an MVC application. Besides applying context
against with expressions are evaluated, scopes allow us to:

- access and manipulate the model.
- set event listeners to watch for whenever the model changes.
- enlighten Angular about asynchronous changes to the model.

## Accessing and Manipulating the Model

Reading and writing to the model with the scope can be as simple as using an
expression in the template. In that case, we work with the **root scope**. The
root scope is the parent scope of the application. In Angular, scopes are
arranged in an heirarchy, and they can prototypically inherit from one another.

### Example

In *Black and Yellow*, we will create two buttons that toggle the color of a
circle between two colors, black and yellow.

*examples/blackandyellow/index.html*

    ::html
    <h1>Black and Yellow</h1>
    <div style="background: {{ color }}" ng-init="color = 'white'"></div>
    <button ng-click="color= 'black'">Black</button>
    <button ng-click="color= 'yellow'">Yellow</button>

We instantiate the ```color``` attribute on the root scope with the ```ng-
init``` directive. We have the ```div``` watch for changes to ```color``` with
the placeholder. Whenever ```color``` changes, the background of the ```div```
will change.

To register this behavior with the buttons, we use the ```ng-click``` directive
which attaches an event handler to the DOM element. For the yellow button, we
attach the expression, ```color = 'yellow'```, which will set the attribute of
the scope to be *yellow*.

![blackandyellow](/img/blackandyellow.png)

## *$watch*ing the Model

Sometimes, we want to observe the model for changes. The ```scope``` object
exposes an application programming interface (API), a handful abstracted useful
functions. Among these functions is ```$watch```, which observes an attribute
on the scope and runs a callback function whenever that attribute changes.

```$watch``` allows us to do more than just reading and writing attributes on
the scope. In the callback function, we can run additional logic that
transcends one-to-one DOM manipulation between the model and the view.

It is worth noting that Angular prefixes the names of its objects and
attributes with ```$``` to avoid accidental namespace collisions.

### Example

In *Gentleman*, we want to blink an image when both of two checkboxes are
checked, but to stop blinking when either of the two checkboxes are unchecked.

*examples/gentleman/index.html*

    ::html
    <body ng-controller="GentlemanCtrl">
      <h1>Gentleman</h1>
      <img src="gentleman.png">
      <input type="checkbox" ng-model="mother">
      <label>Mother</label>
      <input type="checkbox" ng-model="father">
      <label>Father</label>
    </body>

Our last example was simple enough to warrant not needing controllers, where we
were able to set up the initial state and behavior through expressions alone.
Though this example is slightly more complex; we need to be able to
conditionally set intervals and clear stored timeouts.

To observe the checkboxes, we want a scope object for its ```$watch```
function. We will need to make use of a **controller**. Controllers let us set
up the initial state and add behavior to scope objects. We use the
```ng-controller``` directive to hook our ```GentlemanCtrl``` controller to the
template.

*examples/gentleman/app.js*

    ::js
    function GentlemanCtrl($scope) {
        var timeout;

        $scope.$watch('mother', function(newVal, oldVal) {
            if (newVal && $scope.father) {
                // 'Mother' and 'Father' checked.
                motherfather();
            } else if (!newVal) {
                // 'Mother' unchecked.
                clearTimeout(timeout);
            }
        });

        $scope.$watch('father', function(newVal, oldVal) {
            if (newVal && $scope.mother) {
                motherfather();
            } else if (!newVal) {
                clearTimeout(timeout);
            }
        });

        function motherfather() {
            timeout = setInterval(function() {
                $('img').toggleClass('show');
            }, 500);
        }
    }

In the controller, we can ask Angular for the ```$scope``` object by asking for
it as a parameter. We set a ```$watch``` on the scope on ```mother``` and
```father```. When either attribute changes value, the supplied callback
function will execute.

![gentleman](/img/gentleman.png)

## *$apply**ing Changes from Non-Angular Runtime

Scopes let us notify Angular about model changes that occur outside of Angular.
Angular splits the browser-event loop into two separate **runtimes**, or
execution contexts, into classical and Angular runtimes. Only operations that
happen within Angular runtime will propagate to, or update, the view.

Instances of non-Angular runtimes include:

- browser DOM events
- setTimeout or setInterval
- asynchronous XMLHttpRequests (XHR or AJAX)
- third-party libraries such as Socket.IO

When the model changes through these events, we need to call ```$apply``` when
we want to refresh the data-binding from the model to the view.
