title: Templates, Window to the Soul
category: chapter
slug: templates
chapter: 003

---

Angular **templates** are an enhanced specification of HTML that, along with
information from the model, becomes the rendered view that the user sees in the
browser. Recall that the view, in the MVC pattern, generates the output
representation with assistance from the model.

The templates were designed, through the use of directives, to be more
declarative for specifying UI. They are the standard, static DOM sprinkled with
various Angular elements that add behavior to make the view more dynamic and
more closely binded with the model.

Angular seasons several different types of spices on top of standard HTML,

- **expressions** that are evaluated JS-like code snippets placed in
  bindings.
- directives that augment existing DOM elements or represent a reusable
  component.
- form controls that allow the user to input and allow the application to
  validate data.
- **filters** that format or prettify data for display.

## Angular Expressions

Angular expressions are like inline JS snippets in the template,
though, following MVC, they are purposely limited in power. They are often
placed in bindings in the form of ```{{ expression }} ``` or in quotes for some
directives.

In previous chapters, we have already been using expressions to evaluate
properties against scopes and to specify event handlers. They can also evaluate
simple mathematical and logical expressions. Example expressions might be

- 1 + 1 * 42
- someScopeAttr
- someScopeAttr || someOtherScopeAttr
- someScopeMethod()

Expressions can also be separated by semicolons. A case where this would be
useful would be within the ```ng-init``` directive, where we could initialize
multiple properties on the scope.

### Angular Expressions vs. Javascript Expressions

Angular expressions are not simply ```eval()```ed JS expressions. Angular
expressions are like a subset of JS expressions. There are several notable
distinctions between the two. Angular

- evaluates attributes against the scope, whereas JS would evaluate
  against the global ```window```.
- resolves errors and exceptions to ```undefined``` or ```null```,
  whereas JS would throw an exception.
- contains no control flow constructs such as conditionals or loops.

### Example

In *An NBA Poem*, we will write a poem involving some basketball memes to
demonstrate Angular expressions.

*examples/annbapoem/index.html*

    ::html
    <body ng-init="theDeludedOne = 'monta'; lebronRings = 0; bromance = true;">
    Not {{ lebronRings + 1 }}. Not {{ lebronRings + 2 }}. Not {{ lebronRings + 3 }}.

    Because {{ theDeludedOne }} have it all.

    {{ chris || 'Cliff' }} and {{ cliff || 'Chris' }} Paul, hoping for the championship.

    While {{ bromance && 'Parsons' || 'Basketball' }} and Lin, a most delicate relationship.

With the scope property ```lebronRings``` initialized to "0", we can perform
simple addition such as in ```{{ lebronRings + 1 }}}``` to yield "1".

Or we can simply output properties, as is, as a string. Such is the case where
```{{ theDeludedOne }}``` evaluates to "monta".

Because expressions are forgiving, even though  ```chris``` has not been
defined, ```{{ chris || 'Cliff' }}``` still evaluates to "Cliff". Attempting to
evaluate this expression in JS would raise a "ReferenceError: chris is not
defined", on the other hand.

The expression ```{{ chris || 'Cliff' }}``` also demonstrates the use of
boolean logic to accomplish a simple conditional without any control flow
constructs. It evaluates ```chris``` if it exists, else it evalutes to "Cliff".

#### Ternary Operations in Expressions

Often in templates, an ```if then else``` kind of evaluation is useful. Angular
expressions do not contain any control flow constructs, however. Traditionally
in JS, we could use an ```if then else``` flow.

    ::js
    if (a) {
        return b;
    } else {
        return c;
    }

JS contains the ternary operator, to make it more succinct

    ::js
    return a ? b : c;

Angular expressions do not contain the ternary operator. Equivalently, we can
use boolean logic to achieve the same control. In *An NBA Poem*, the expression
```{{ bromance && 'Parsons' || 'Basketball }}``` demonstrates an
```if then else``` evaluation. If ```bromance``` is not falsy, then the
expression evaluates to "Parsons", else it evaluates to "Basketball".

## Built-in Directives

Directives teach HTML new tricks and allows us to forge reusable widgets.
Already, we have been using basic built-in Angular directives such as
```ng- app```, ```ng-model```, ```ng- controller```, or ```ng-click```.

Built-in directives can declared in all of several different styles, via

- element: ```<directive></directive>```
- attribute: ```<div directive="expression"></div>```
- class: ```<div class="directive = 'expression"></div>```
- comment: ```<!--directive: expression-->```

We will delve deeper into directives, and how to craft custom directives, in
*Directives, Teaching an Old HTML New Tricks*.

For now, we will cover some other useful directives that have not yet been
covered. The official Angular documentation contains an API reference detailing
all of the directives, totaling over 50 at time of writing.

###ng-class

```ng-class``` allows us to dynamically set CSS classes. We pass an expression
containing class names that are either space-delimited, in an array, or in a
map that maps the classes to boolean values. Often, we use scope properties
to conditionally determine whether a class is to be set.

Note classes set with ```ng-class``` are *appended* to the classes normally set
via the HTML ```class``` attribute.

#### Example

In *Transformer*, we will create checkboxes that will set classes to transform
an HTML element to demonstrate ```ng-class```.

*examples/transformer/index.html*

    ::html
    <div class="box" ng-class="{'border': border, 'circle': circle, 'red': red,
                                'rotate': rotate, 'scale': scale}"></div>
    <input id="rotate" type="checkbox" ng-model="rotate">
    <label for="rotate">Rotate</label>

We pass a mapping of classes to expressions. If the expressions are truthy,
then the class is set. For example, enabling the ```#rotate``` input will set
```rotate``` to ```true```. The "rotate" class will then be added to the
```div``` on top of its "box" class.

![transformer](/img/transformer.png)

#### Setting Classes on Specific Values

We can also conditionally set classes based on the specific value of a scope
property with ```ng-class```. In *Transfomer*, pretend ```rotate```'s possible
values are "rotateSmall", "rotateMed", and "rotateLarge". For each, we wish to
set different classes.

    ::html
    <div class="box" ng-class="{rotateSmall: 'rotateSmall red',
                                rotateMed: 'rotateMed green'
                                rotateLarge: 'rotateLarge blue'}[rotate]"></div>


Instead mapping from class names to boolean values, we can map from
property values to class names. We use the scope property to fish the desired
classes. For example, if ```rotate``` is "rotateSmall", then the ```div``` will
have the classes "rotateSmall" and "red".

###ng-repeat

###ng-include

## Form Controls

Angular even overrides ```form``` and ```input``` elements for data-binding.
